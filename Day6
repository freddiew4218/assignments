1. Six combinations of access modifier keywords in C#:

   - public: The member is accessible from any other code.
   - private: The member is accessible only within the body of the class or the struct in which it is declared.
   - protected: The member is accessible within its class and by derived class instances.
   - internal: The member is accessible only within files in the same assembly.
   - protected internal: The member is accessible within its class, by derived class instances, and within the same assembly.
   - private protected: The member is accessible within its class and by derived class instances that are within the same assembly.

2. Difference between static, const, and readonly keywords:

   - static: The member belongs to the type itself rather than to a specific object. It's shared among all instances of the type.
   - const: The member is a compile-time constant. It is implicitly static and cannot be changed after it is declared and initialized.
   - readonly: The member can only be assigned during declaration or in a constructor of the same class. It can be used for run-time constants.

3. Constructor:
   - A constructor is a special method of a class that is automatically called when an instance of the class is created. It initializes the object and can set default values or perform other setup tasks.

4. partial keyword:
   - The `partial` keyword allows a class, struct, or interface to be split across multiple files. This is useful for organizing code, especially when different parts of the class are generated by tools or need to be kept separate for readability.

5. Tuple:
   - A tuple is a data structure that can hold multiple values of different types. In C#, tuples are used to group together related values without creating a specific class or struct.

6. record keyword:
   - The `record` keyword defines a reference type that provides built-in functionality for encapsulating data with value equality, meaning records are compared based on their values rather than their references.

7. Overloading and overriding:

   - Overloading: Defining multiple methods with the same name but different parameters (type, number, or both) within the same scope.
   - Overriding: Providing a new implementation for a method in a derived class that was defined in a base class and marked with the `virtual`, `abstract`, or `override` keyword.

8. Field vs. Property:

   - Field: A variable declared directly in a class or struct. It is used to store data directly.
   - Property: A member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can have logic in their getters and setters.

9. Making a method parameter optional:
   - Use default parameter values. Example: `void MyMethod(int x, int y = 10)`

10. Interface vs. Abstract class:

    - Interface: Defines a contract with no implementation. All members are abstract by default. A class can implement multiple interfaces.
    - Abstract class: Can have both abstract members (without implementation) and non-abstract members (with implementation). A class can inherit only one abstract class but can implement multiple interfaces.

11. Accessibility level of members of an interface:
    - All members of an interface are implicitly public.

12. True/False: Polymorphism allows derived classes to provide different implementations of the same method.
    - True

13. True/False: The override keyword is used to indicate that a method in a derived class is providing its own implementation of a method.
    - True

14. True/False: The new keyword is used to indicate that a method in a derived class is providing its own implementation of a method.
    - True (with the caveat that `new` hides a member of the base class, rather than overriding it)

15. True/False: Abstract methods can be used in a normal (non-abstract) class.
    - False

16. True/False: Normal (non-abstract) methods can be used in an abstract class.
    - True

17. True/False: Derived classes can override methods that were virtual in the base class.
    - True

18. True/False: Derived classes can override methods that were abstract in the base class.
    - True

19. True/False: In a derived class, you can override a method that was neither virtual nor abstract in the base class.
    - False

20. True/False: A class that implements an interface does not have to provide an implementation for all of the members of the interface.
    - False

21. True/False: A class that implements an interface is allowed to have other members that arenâ€™t defined in the interface.
    - True

22. True/False: A class can have more than one base class.
    - False

23. True/False: A class can implement more than one interface.
    - True


Coding #1:
using System;

class Program
{
    static void Main(string[] args)
    {
        int[] numbers = GenerateNumbers(10);
        Reverse(numbers);
        PrintNumbers(numbers);
    }

    static int[] GenerateNumbers(int length)
    {
        int[] numbers = new int[length];
        for (int i = 0; i < length; i++)
        {
            numbers[i] = i + 1;
        }
        return numbers;
    }

    static void Reverse(int[] array)
    {
        int length = array.Length;
        for (int i = 0; i < length / 2; i++)
        {
            int temp = array[i];
            array[i] = array[length - i - 1];
            array[length - i - 1] = temp;
        }
    }

    static void PrintNumbers(int[] array)
    {
        foreach (int number in array)
        {
            Console.Write(number + " ");
        }
        Console.WriteLine();
    }
}

Coding #2:

using System;

class Program
{
    static void Main(string[] args)
    {
        for (int i = 1; i <= 10; i++)
        {
            Console.WriteLine($"Fibonacci({i}) = {Fibonacci(i)}");
        }
    }

    static int Fibonacci(int n)
    {
        if (n <= 2)
            return 1;
        else
            return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}


Coding #3:

using System;
using System.Collections.Generic;

namespace OOPDemo
{
    interface IPersonService
    {
        int CalculateAge();
        decimal CalculateSalary();
        List<string> GetAddresses();
    }

    interface IStudentService : IPersonService
    {
        double CalculateGPA();
    }

    interface IInstructorService : IPersonService
    {
        void AssignDepartment(string department);
    }

    class Person
    {
        public string Name { get; set; }
        public DateTime BirthDate { get; set; }
        public decimal Salary { get; protected set; }
        private List<string> Addresses { get; set; }

        public Person(string name, DateTime birthDate)
        {
            Name = name;
            BirthDate = birthDate;
            Addresses = new List<string>();
        }

        public void AddAddress(string address)
        {
            Addresses.Add(address);
        }

        public List<string> GetAddresses()
        {
            return Addresses;
        }

        public virtual decimal CalculateSalary()
        {
            return Salary;
        }

        public int CalculateAge()
        {
            var today = DateTime.Today;
            var age = today.Year - BirthDate.Year;
            if (BirthDate.Date > today.AddYears(-age)) age--;
            return age;
        }
    }

    class Student : Person, IStudentService
    {
        private List<double> Grades { get; set; }

        public Student(string name, DateTime birthDate) : base(name, birthDate)
        {
            Grades = new List<double>();
        }

        public void AddGrade(double grade)
        {
            Grades.Add(grade);
        }

        public double CalculateGPA()
        {
            double total = 0;
            foreach (var grade in Grades)
            {
                total += grade;
            }
            return Grades.Count > 0 ? total / Grades.Count : 0;
        }
    }

    class Instructor : Person, IInstructorService
    {
        public string Department { get; private set; }
        public DateTime JoinDate { get; set; }

        public Instructor(string name, DateTime birthDate, DateTime joinDate) : base(name, birthDate)
        {
            JoinDate = joinDate;
        }

        public override decimal CalculateSalary()
        {
            var experience = DateTime.Today.Year - JoinDate.Year;
            if (JoinDate.Date > DateTime.Today.AddYears(-experience)) experience--;
            return base.CalculateSalary() + experience * 1000; // Added bonus for experience
        }

        public void AssignDepartment(string department)
        {
            Department = department;
        }
    }

    class Course
    {
        public string Name { get; set; }
        public List<Student> EnrolledStudents { get; set; }

        public Course(string name)
        {
            Name = name;
            EnrolledStudents = new List<Student>();
        }

        public void EnrollStudent(Student student)
        {
            EnrolledStudents.Add(student);
        }
    }

    class Department
    {
        public string Name { get; set; }
        public Instructor Head { get; set; }
        public decimal Budget { get; set; }
        public List<Course> Courses { get; set; }

        public Department(string name, decimal budget)
        {
            Name = name;
            Budget = budget;
            Courses = new List<Course>();
        }

        public void SetHead(Instructor head)
        {
            Head = head;
        }

        public void AddCourse(Course course)
        {
            Courses.Add(course);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Instructor instructor = new Instructor("John Doe", new DateTime(1980, 1, 1), new DateTime(2005, 6, 1));
            Student student = new Student("Jane Smith", new DateTime(2000, 5, 15));
            Department department = new Department("Computer Science", 100000);
            Course course = new Course("Programming 101");

            instructor.AssignDepartment(department.Name);
            department.SetHead(instructor);
            department.AddCourse(course);
            course.EnrollStudent(student);

            student.AddGrade(90);
            student.AddGrade(85);

            instructor.AddAddress("123 Main St.");
            student.AddAddress("456 Elm St.");

            Console.WriteLine($"{instructor.Name} (Age: {instructor.CalculateAge()}) - Department: {instructor.Department}, Salary: {instructor.CalculateSalary()}");
            Console.WriteLine($"{student.Name} (Age: {student.CalculateAge()}) - GPA: {student.CalculateGPA()}");
            Console.WriteLine($"Department Head: {department.Head.Name}, Budget: {department.Budget}");
        }
    }
}


Coding #4:

using System;

class Color
{
    public int Red { get; private set; }
    public int Green { get; private set; }
    public int Blue { get; private set; }
    public int Alpha { get; private set; }

    public Color(int red, int green, int blue, int alpha = 255)
    {
        Red = red;
        Green = green;
        Blue = blue;
        Alpha = alpha;
    }

    public void SetRed(int red) => Red = red;
    public void SetGreen(int green) => Green = green;
    public void SetBlue(int blue) => Blue = blue;
    public void SetAlpha(int alpha) => Alpha = alpha;

    public double GetGrayscale()
    {
        return (Red + Green + Blue) / 3.0;
    }
}

class Ball
{
    public int Size { get; private set; }
    public Color Color { get; private set; }
    private int throwCount;

    public Ball(int size, Color color)
    {
        Size = size;
        Color = color;
        throwCount = 0;
    }

    public void Pop()
    {
        Size = 0;
    }

    public void Throw()
    {
        if (Size > 0)
        {
            throwCount++;
        }
    }

    public int GetThrowCount()
    {
        return throwCount;
    }
}

class Program
{
    static void Main(string[] args)
    {
        Color red = new Color(255, 0, 0);
        Ball ball1 = new Ball(10, red);
        
        ball1.Throw();
        ball1.Throw();
        Console.WriteLine($"Ball1 throw count: {ball1.GetThrowCount()}"); // Output: 2

        ball1.Pop();
        ball1.Throw();
        Console.WriteLine($"Ball1 throw count after pop: {ball1.GetThrowCount()}"); // Output: 2

        Color blue = new Color(0, 0, 255, 128);
        Ball ball2 = new Ball(15, blue);
        
        ball2.Throw();
        Console.WriteLine($"Ball2 throw count: {ball2.GetThrowCount()}"); // Output: 1
    }
}


Designing and Building Classes using object-oriented principles:

Interfaces:

public interface IPersonService
{
    int CalculateAge();
    decimal CalculateSalary();
    List<string> GetAddresses();
}

public interface IStudentService : IPersonService
{
    double CalculateGPA();
}

public interface IInstructorService : IPersonService
{
    void AssignDepartment(string department);
}
Base Person Class:

public abstract class Person : IPersonService
{
    public string Name { get; set; }
    public DateTime BirthDate { get; set; }
    private List<string> Addresses { get; set; }
    protected decimal Salary { get; set; }

    public Person(string name, DateTime birthDate)
    {
        Name = name;
        BirthDate = birthDate;
        Addresses = new List<string>();
        Salary = 0;
    }

    public void AddAddress(string address)
    {
        Addresses.Add(address);
    }

    public List<string> GetAddresses()
    {
        return Addresses;
    }

    public abstract decimal CalculateSalary();

    public int CalculateAge()
    {
        var today = DateTime.Today;
        var age = today.Year - BirthDate.Year;
        if (BirthDate.Date > today.AddYears(-age)) age--;
        return age;
    }
}
Student Class:

public class Student : Person, IStudentService
{
    private List<double> Grades { get; set; }

    public Student(string name, DateTime birthDate) : base(name, birthDate)
    {
        Grades = new List<double>();
    }

    public void AddGrade(double grade)
    {
        Grades.Add(grade);
    }

    public double CalculateGPA()
    {
        double total = 0;
        foreach (var grade in Grades)
        {
            total += grade;
        }
        return Grades.Count > 0 ? total / Grades.Count : 0;
    }

    public override decimal CalculateSalary()
    {
        return 0; // Students don't have a salary in this context
    }
}
Instructor Class:

public class Instructor : Person, IInstructorService
{
    public string Department { get; private set; }
    public DateTime JoinDate { get; set; }

    public Instructor(string name, DateTime birthDate, DateTime joinDate) : base(name, birthDate)
    {
        JoinDate = joinDate;
    }

    public override decimal CalculateSalary()
    {
        var experience = DateTime.Today.Year - JoinDate.Year;
        if (JoinDate.Date > DateTime.Today.AddYears(-experience)) experience--;
        return Salary + experience * 1000; // Added bonus for experience
    }

    public void AssignDepartment(string department)
    {
        Department = department;
    }
}
Course Class:

public class Course
{
    public string Name { get; set; }
    public List<Student> EnrolledStudents { get; set; }

    public Course(string name)
    {
        Name = name;
        EnrolledStudents = new List<Student>();
    }

    public void EnrollStudent(Student student)
    {
        EnrolledStudents.Add(student);
    }
}
Department Class:

public class Department
{
    public string Name { get; set; }
    public Instructor Head { get; set; }
    public decimal Budget { get; set; }
    public List<Course> Courses { get; set; }

    public Department(string name, decimal budget)
    {
        Name = name;
        Budget = budget;
        Courses = new List<Course>();
    }

    public void SetHead(Instructor head)
    {
        Head = head;
    }

    public void AddCourse(Course course)
    {
        Courses.Add(course);
    }
}

Task 4: Color and Ball Classes
Color Class:


public class Color
{
    public int Red { get; private set; }
    public int Green { get; private set; }
    public int Blue { get; private set; }
    public int Alpha { get; private set; }

    public Color(int red, int green, int blue, int alpha = 255)
    {
        Red = red;
        Green = green;
        Blue = blue;
        Alpha = alpha;
    }

    public void SetRed(int red) => Red = red;
    public void SetGreen(int green) => Green = green;
    public void SetBlue(int blue) => Blue = blue;
    public void SetAlpha(int alpha) => Alpha = alpha;

    public double GetGrayscale()
    {
        return (Red + Green + Blue) / 3.0;
    }
}
Ball Class:


public class Ball
{
    public int Size { get; private set; }
    public Color Color { get; private set; }
    private int throwCount;

    public Ball(int size, Color color)
    {
        Size = size;
        Color = color;
        throwCount = 0;
    }

    public void Pop()
    {
        Size = 0;
    }

    public void Throw()
    {
        if (Size > 0)
        {
            throwCount++;
        }
    }

    public int GetThrowCount()
    {
        return throwCount;
    }
}
Main Program for Color and Ball:


class Program
{
    static void Main(string[] args)
    {
        Color red = new Color(255, 0, 0);
        Ball ball1 = new Ball(10, red);
        
        ball1.Throw();
        ball1.Throw();
        Console.WriteLine($"Ball1 throw count: {ball1.GetThrowCount()}"); // Output: 2

        ball1.Pop();
        ball1.Throw();
        Console.WriteLine($"Ball1 throw count after pop: {ball1.GetThrowCount()}"); // Output: 2

        Color blue = new Color(0, 0, 255, 128);
        Ball ball2 = new Ball(15, blue);
        
        ball2.Throw();
        Console.WriteLine($"Ball2 throw count: {ball2.GetThrowCount()}"); // Output: 1
    }
}

